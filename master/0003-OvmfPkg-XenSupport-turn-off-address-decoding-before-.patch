From c5acae322b64c654eaef08732f8021b40ff72aa2 Mon Sep 17 00:00:00 2001
From: Igor Druzhinin <igor.druzhinin@citrix.com>
Date: Fri, 24 Aug 2018 23:42:17 +0100
Subject: [PATCH 3/3] OvmfPkg/XenSupport: turn off address decoding before BAR
 sizing

On Xen, hvmloader firmware leaves address decoding enabled for
enumerated PCI device before jumping into OVMF. OVMF seems to
expect it to be disabled and tries to size PCI BARs in several places
without disabling it which causes BAR64, for example, being
incorrectly placed by QEMU.

Fix it by disabling PCI address decoding explicitly before the
first attempt to size BARs on Xen.

Signed-off-by: Igor Druzhinin <igor.druzhinin@citrix.com>
---
 OvmfPkg/Library/PciHostBridgeLib/XenSupport.c | 50 +++++++++++++++++++++++++++
 1 file changed, 50 insertions(+)

diff --git a/OvmfPkg/Library/PciHostBridgeLib/XenSupport.c b/OvmfPkg/Library/PciHostBridgeLib/XenSupport.c
index 408fb24..01560be 100644
--- a/OvmfPkg/Library/PciHostBridgeLib/XenSupport.c
+++ b/OvmfPkg/Library/PciHostBridgeLib/XenSupport.c
@@ -27,6 +27,9 @@
 #include <Library/PciLib.h>
 #include "PciHostBridge.h"
 
+#define PCI_VENDOR_ID_XEN    0x5853
+#define PCI_DEVICE_ID_VAR    0x0003
+
 STATIC
 VOID
 PcatPciRootBridgeBarExisted (
@@ -55,6 +58,33 @@ PcatPciRootBridgeBarExisted (
   EnableInterrupts ();
 }
 
+#define EFI_PCI_COMMAND_DECODE ((UINT16)(EFI_PCI_COMMAND_IO_SPACE | \
+                                         EFI_PCI_COMMAND_MEMORY_SPACE))
+STATIC
+VOID
+PcatPciRootBridgeDecoding (
+  IN  UINTN                          Address,
+  IN  BOOLEAN                        Enabled,
+  OUT UINT16                         *OriginalValue
+  )
+{
+  UINT16                            Value;
+
+  //
+  // Preserve the original value
+  //
+  Value = *OriginalValue;
+  *OriginalValue = PciRead16 (Address);
+
+  if (!Enabled) {
+    if (*OriginalValue & EFI_PCI_COMMAND_DECODE)
+       PciWrite16 (Address, *OriginalValue & ~EFI_PCI_COMMAND_DECODE);
+  } else {
+    if (Value & EFI_PCI_COMMAND_DECODE)
+      PciWrite16 (Address, Value);
+  }
+}
+
 STATIC
 VOID
 PcatPciRootBridgeParseBars (
@@ -76,12 +106,24 @@ PcatPciRootBridgeParseBars (
   UINT32                            Value;
   UINT32                            OriginalUpperValue;
   UINT32                            UpperValue;
+  UINT16                            OriginalCommand;
   UINT64                            Mask;
   UINTN                             Offset;
   UINT64                            Base;
   UINT64                            Length;
   UINT64                            Limit;
   PCI_ROOT_BRIDGE_APERTURE          *MemAperture;
+  UINT16                            VendorId;
+  UINT16                            DeviceId;
+
+  VendorId = PciRead16(PCI_LIB_ADDRESS(Bus, Device, Function, PCI_VENDOR_ID_OFFSET));
+  DeviceId = PciRead16(PCI_LIB_ADDRESS(Bus, Device, Function, PCI_DEVICE_ID_OFFSET));
+
+  // Disable address decoding for every device before OVMF starts sizing it
+  PcatPciRootBridgeDecoding (
+    PCI_LIB_ADDRESS (Bus, Device, Function, PCI_COMMAND_OFFSET),
+    FALSE, &OriginalCommand
+  );
 
   for (Offset = BarOffsetBase; Offset < BarOffsetEnd; Offset += sizeof (UINT32)) {
     PcatPciRootBridgeBarExisted (
@@ -164,6 +206,14 @@ PcatPciRootBridgeParseBars (
       }
     }
   }
+
+  // Enable decoding for XenVariable device only as we need it in PEI
+  if (VendorId == PCI_VENDOR_ID_XEN && DeviceId == PCI_DEVICE_ID_VAR) {
+    PcatPciRootBridgeDecoding (
+      PCI_LIB_ADDRESS (Bus, Device, Function, PCI_COMMAND_OFFSET),
+      TRUE, &OriginalCommand
+    );
+  }
 }
 
 PCI_ROOT_BRIDGE *
-- 
2.7.4

