diff --git a/OvmfPkg/OvmfPkgX64.dsc b/OvmfPkg/OvmfPkgX64.dsc
index 47e187c2fc..78519f9339 100644
--- a/OvmfPkg/OvmfPkgX64.dsc
+++ b/OvmfPkg/OvmfPkgX64.dsc
@@ -41,6 +41,7 @@
   DEFINE TLS_ENABLE              = FALSE
   DEFINE TPM2_ENABLE             = FALSE
   DEFINE IPXE_ENABLE             = FALSE
+  DEFINE XEN_VARIABLE_ENABLE     = FALSE
 
   #
   # Flash size selection. Setting FD_SIZE_IN_KB on the command line directly to
@@ -190,7 +191,9 @@
   TpmMeasurementLib|MdeModulePkg/Library/TpmMeasurementLibNull/TpmMeasurementLibNull.inf
   AuthVariableLib|MdeModulePkg/Library/AuthVariableLibNull/AuthVariableLibNull.inf
 !endif
+!if $(XEN_VARIABLE_ENABLE) == FALSE
   VarCheckLib|MdeModulePkg/Library/VarCheckLib/VarCheckLib.inf
+!endif
 
 !if $(NETWORK_IP6_ENABLE) == TRUE
   TcpIoLib|MdeModulePkg/Library/DxeTcpIoLib/DxeTcpIoLib.inf
@@ -921,6 +924,9 @@
   #
   # Variable driver stack (non-SMM)
   #
+!if $(XEN_VARIABLE_ENABLE) == TRUE
+  OvmfPkg/XenVariable/XenVariable.inf
+!else
   OvmfPkg/QemuFlashFvbServicesRuntimeDxe/FvbServicesRuntimeDxe.inf
   OvmfPkg/EmuVariableFvbRuntimeDxe/Fvb.inf {
     <LibraryClasses>
@@ -932,6 +938,7 @@
       NULL|MdeModulePkg/Library/VarCheckUefiLib/VarCheckUefiLib.inf
   }
 !endif
+!endif
 
 !if $(TPM2_ENABLE) == TRUE
   SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.inf {
diff --git a/OvmfPkg/OvmfPkgX64.fdf b/OvmfPkg/OvmfPkgX64.fdf
index f2e1fa8506..dba683c6e6 100644
--- a/OvmfPkg/OvmfPkgX64.fdf
+++ b/OvmfPkg/OvmfPkgX64.fdf
@@ -197,9 +197,11 @@ APRIORI DXE {
   INF  MdeModulePkg/Universal/DevicePathDxe/DevicePathDxe.inf
   INF  MdeModulePkg/Universal/PCD/Dxe/Pcd.inf
   INF  OvmfPkg/AmdSevDxe/AmdSevDxe.inf
+!if $(XEN_VARIABLE_ENABLE) == FALSE
 !if $(SMM_REQUIRE) == FALSE
   INF  OvmfPkg/QemuFlashFvbServicesRuntimeDxe/FvbServicesRuntimeDxe.inf
 !endif
+!endif
 }
 
 #
@@ -393,11 +395,15 @@ INF  MdeModulePkg/Universal/Variable/RuntimeDxe/VariableSmmRuntimeDxe.inf
 #
 # Variable driver stack (non-SMM)
 #
+!if $(XEN_VARIABLE_ENABLE) == TRUE
+INF  OvmfPkg/XenVariable/XenVariable.inf
+!else
 INF  OvmfPkg/QemuFlashFvbServicesRuntimeDxe/FvbServicesRuntimeDxe.inf
 INF  OvmfPkg/EmuVariableFvbRuntimeDxe/Fvb.inf
 INF  MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteDxe.inf
 INF  MdeModulePkg/Universal/Variable/RuntimeDxe/VariableRuntimeDxe.inf
 !endif
+!endif
 
 !if $(TPM2_ENABLE) == TRUE
 INF  SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.inf
diff --git a/OvmfPkg/XenVariable/XenVariable.c b/OvmfPkg/XenVariable/XenVariable.c
new file mode 100644
index 0000000000..5b047ac4fc
--- /dev/null
+++ b/OvmfPkg/XenVariable/XenVariable.c
@@ -0,0 +1,509 @@
+#include "XenVariable.h"
+#include "Library/IoLib.h"
+#include <Library/PciLib.h>
+#include <IndustryStandard/Pci.h>
+#include <Library/SynchronizationLib.h>
+
+static EFI_EVENT mXenVirtualAddressChangeEvent = NULL;
+
+static SPIN_LOCK var_lock;
+
+static VOID *comm_buf_phys;
+VOID *comm_buf;
+
+#define PCI_VENDOR_ID_XEN    0x5853
+#define PCI_DEVICE_ID_VAR    0x0003
+
+#define PCI_BAR_IO_SPACE     0x1
+#define PCI_BAR_SPACE_MASK   0x3
+
+static BOOLEAN
+get_bar_addr(UINT8 slot, UINTN *bar_addr)
+{
+  UINT16 vend = PciRead16(PCI_LIB_ADDRESS(0, slot, 0, PCI_VENDOR_ID_OFFSET));
+  UINT16 dev = PciRead16(PCI_LIB_ADDRESS(0, slot, 0, PCI_DEVICE_ID_OFFSET));
+
+  if (vend == PCI_VENDOR_ID_XEN && dev == PCI_DEVICE_ID_VAR) {
+    *bar_addr = PciRead32(PCI_LIB_ADDRESS(0, slot, 0, PCI_BASE_ADDRESSREG_OFFSET));
+    ASSERT((*bar_addr & PCI_BAR_IO_SPACE) == PCI_BAR_IO_SPACE);
+    *bar_addr &= (UINT16) ~PCI_BAR_SPACE_MASK;
+    return TRUE;
+  } else {
+    return FALSE;
+  }
+}
+
+static UINT16
+find_xv_pci_port(void)
+{
+  static UINT8 last_slot = 0;
+
+  UINT8 slot;
+  UINTN bar_addr;
+
+  if (get_bar_addr(last_slot, &bar_addr))
+    return bar_addr;
+
+  for (slot = 0; slot <= PCI_MAX_DEVICE; slot++)
+    if (slot != last_slot && get_bar_addr(slot, &bar_addr)) {
+      last_slot = slot;
+      return bar_addr;
+    }
+  DEBUG((EFI_D_INFO, "Failed to find Xen Variable Device\n"));
+  CpuDeadLoop();
+  return 0;
+}
+
+#if 0
+static void dump_data(VOID *data, UINT32 len)
+{
+#ifndef MDEPKG_NDEBUG
+  UINT8 *ptr = data;
+  int i;
+
+  for (i = 0; i < len; i++) {
+    if (i % 20 == 0)
+      DEBUG ((EFI_D_INFO, "\n"));
+    DEBUG ((EFI_D_INFO, "%02x ", ptr[i]));
+  }
+#endif
+}
+#endif
+
+enum command_t {
+  COMMAND_GET_VARIABLE,
+  COMMAND_SET_VARIABLE,
+  COMMAND_GET_NEXT_VARIABLE,
+  COMMAND_QUERY_VARIABLE_INFO,
+};
+
+static void
+serialize_name(UINT8 **ptr, CHAR16 *VariableName)
+{
+  UINTN VarNameSize = StrLen(VariableName) * sizeof(*VariableName);
+  CopyMem (*ptr, &VarNameSize, sizeof VarNameSize);
+  *ptr += sizeof VarNameSize;
+  CopyMem (*ptr, VariableName, VarNameSize);
+  *ptr += VarNameSize;
+}
+
+static void
+serialize_data(UINT8 **ptr, VOID *Data, UINTN DataSize)
+{
+  CopyMem (*ptr, &DataSize, sizeof DataSize);
+  *ptr += sizeof DataSize;
+  CopyMem (*ptr, Data, DataSize);
+  *ptr += DataSize;
+}
+
+static void
+serialize_uintn(UINT8 **ptr, UINTN var)
+{
+  CopyMem (*ptr, &var, sizeof var);
+  *ptr += sizeof var;
+}
+
+static void
+serialize_uint32(UINT8 **ptr, UINT32 var)
+{
+  CopyMem (*ptr, &var, sizeof var);
+  *ptr += sizeof var;
+}
+
+static void
+serialize_boolean(UINT8 **ptr, BOOLEAN var)
+{
+  CopyMem (*ptr, &var, sizeof var);
+  *ptr += sizeof var;
+}
+
+static void
+serialize_command(UINT8 **ptr, enum command_t cmd)
+{
+  serialize_uint32(ptr, (UINT32)cmd);
+}
+
+static void
+serialize_guid(UINT8 **ptr, EFI_GUID *Guid)
+{
+  CopyMem (*ptr, Guid, 16);
+  *ptr += 16;
+}
+
+static void
+unserialize_data(UINT8 **ptr, VOID *Data, UINTN *DataSize)
+{
+  CopyMem(DataSize, *ptr, sizeof(*DataSize));
+  *ptr += sizeof(*DataSize);
+#if 0
+  DEBUG ((EFI_D_INFO, "From varstore %lu bytes:", *DataSize));
+  dump_data(*ptr, *DataSize);
+  DEBUG ((EFI_D_INFO, "\n"));
+#endif
+  CopyMem(Data, *ptr, *DataSize);
+  *ptr += *DataSize;
+}
+
+static UINTN
+unserialize_uintn(UINT8 **ptr)
+{
+  UINTN ret;
+
+  CopyMem(&ret, *ptr, sizeof ret);
+  *ptr += sizeof ret;
+
+  return ret;
+}
+
+static UINT32
+unserialize_uint32(UINT8 **ptr)
+{
+  UINT32 ret;
+
+  CopyMem(&ret, *ptr, sizeof ret);
+  *ptr += sizeof ret;
+
+  return ret;
+}
+
+static UINT64
+unserialize_uint64(UINT8 **ptr)
+{
+  UINT64 ret;
+
+  CopyMem(&ret, *ptr, sizeof ret);
+  *ptr += sizeof ret;
+
+  return ret;
+}
+
+static void
+unserialize_guid(UINT8 **ptr, EFI_GUID *Guid)
+{
+  CopyMem (Guid, *ptr, 16);
+  *ptr += 16;
+}
+
+static EFI_STATUS
+unserialize_result(UINT8 **ptr)
+{
+  EFI_STATUS status;
+
+  CopyMem(&status, *ptr, sizeof status);
+  *ptr += sizeof status;
+
+  return status;
+}
+
+static void
+exec_command(void)
+{
+  UINT16 port = find_xv_pci_port();
+
+  MemoryFence ();
+  IoWrite32 (port, ((UINTN)comm_buf_phys) >> 12);
+  MemoryFence ();
+}
+
+EFI_STATUS
+EFIAPI
+XenGetVariableLocked (
+  IN      CHAR16            *VariableName,
+  IN      EFI_GUID          *VendorGuid,
+  OUT     UINT32            *Attributes OPTIONAL,
+  IN OUT  UINTN             *DataSize,
+  OUT     VOID              *Data OPTIONAL
+  )
+{
+  UINT8 *ptr;
+  EFI_STATUS status;
+  UINT32 attr;
+
+  if (!VariableName || !VendorGuid || !DataSize)
+      return EFI_INVALID_PARAMETER;
+
+  ptr = comm_buf;
+  serialize_uint32(&ptr, 1); /* version */
+  serialize_command(&ptr, COMMAND_GET_VARIABLE);
+  serialize_name(&ptr, VariableName);
+  serialize_guid(&ptr, VendorGuid);
+  serialize_uintn(&ptr, *DataSize);
+  serialize_boolean(&ptr, EfiAtRuntime());
+
+  exec_command();
+
+  ptr = comm_buf;
+  status = unserialize_result(&ptr);
+  switch (status) {
+  case EFI_SUCCESS:
+    if (!Data)
+        return EFI_INVALID_PARAMETER;
+    attr = unserialize_uint32(&ptr);
+    if (Attributes)
+        *Attributes = attr;
+    unserialize_data(&ptr, Data, DataSize);
+    break;
+  case EFI_BUFFER_TOO_SMALL:
+    *DataSize = unserialize_uintn(&ptr);
+    break;
+  default:
+    break;
+  }
+
+  return status;
+}
+
+EFI_STATUS
+EFIAPI
+XenGetVariable (
+  IN      CHAR16            *VariableName,
+  IN      EFI_GUID          *VendorGuid,
+  OUT     UINT32            *Attributes OPTIONAL,
+  IN OUT  UINTN             *DataSize,
+  OUT     VOID              *Data OPTIONAL
+  )
+{
+  EFI_STATUS status;
+
+  AcquireSpinLock(&var_lock);
+
+  status = XenGetVariableLocked(VariableName, VendorGuid, Attributes,
+                                DataSize, Data);
+
+  ReleaseSpinLock(&var_lock);
+
+  return status;
+}
+
+EFI_STATUS
+EFIAPI
+XenGetNextVariableNameLocked (
+  IN OUT  UINTN             *VariableNameSize,
+  IN OUT  CHAR16            *VariableName,
+  IN OUT  EFI_GUID          *VendorGuid
+  )
+{
+  UINT8 *ptr;
+  EFI_STATUS status;
+
+  if (!VariableNameSize || !VariableName || !VendorGuid)
+      return EFI_INVALID_PARAMETER;
+
+  if (StrSize(VariableName) > *VariableNameSize)
+      return EFI_INVALID_PARAMETER;
+
+  ptr = comm_buf;
+  serialize_uint32(&ptr, 1); /* version */
+  serialize_command(&ptr, COMMAND_GET_NEXT_VARIABLE);
+  serialize_uintn(&ptr, *VariableNameSize);
+  serialize_name(&ptr, VariableName);
+  serialize_guid(&ptr, VendorGuid);
+  serialize_boolean(&ptr, EfiAtRuntime());
+
+  exec_command();
+
+  ptr = comm_buf;
+  status = unserialize_result(&ptr);
+  switch (status) {
+  case EFI_SUCCESS:
+    unserialize_data(&ptr, VariableName, VariableNameSize);
+    VariableName[*VariableNameSize / 2] = '\0';
+    *VariableNameSize += sizeof(*VariableName);
+    unserialize_guid(&ptr, VendorGuid);
+    break;
+  case EFI_BUFFER_TOO_SMALL:
+    *VariableNameSize = unserialize_uintn(&ptr);
+    break;
+  default:
+    break;
+  }
+  return status;
+}
+
+EFI_STATUS
+EFIAPI
+XenGetNextVariableName (
+  IN OUT  UINTN             *VariableNameSize,
+  IN OUT  CHAR16            *VariableName,
+  IN OUT  EFI_GUID          *VendorGuid
+  )
+{
+  EFI_STATUS status;
+
+  AcquireSpinLock(&var_lock);
+
+  status = XenGetNextVariableNameLocked(VariableNameSize, VariableName,
+                                        VendorGuid);
+
+  ReleaseSpinLock(&var_lock);
+
+  return status;
+}
+
+EFI_STATUS
+EFIAPI
+XenSetVariableLocked (
+  IN CHAR16                  *VariableName,
+  IN EFI_GUID                *VendorGuid,
+  IN UINT32                  Attributes,
+  IN UINTN                   DataSize,
+  IN VOID                    *Data
+  )
+{
+  UINT8 *ptr;
+
+  ptr = comm_buf;
+  serialize_uint32(&ptr, 1); /* version */
+  serialize_command(&ptr, COMMAND_SET_VARIABLE);
+  serialize_name(&ptr, VariableName);
+  serialize_guid(&ptr, VendorGuid);
+  serialize_data(&ptr, Data, DataSize);
+  serialize_uint32(&ptr, Attributes);
+  serialize_boolean(&ptr, EfiAtRuntime());
+
+  exec_command();
+
+  ptr = comm_buf;
+  return unserialize_result(&ptr);
+}
+
+EFI_STATUS
+EFIAPI
+XenSetVariable (
+  IN CHAR16                  *VariableName,
+  IN EFI_GUID                *VendorGuid,
+  IN UINT32                  Attributes,
+  IN UINTN                   DataSize,
+  IN VOID                    *Data
+)
+{
+  EFI_STATUS status;
+
+  AcquireSpinLock(&var_lock);
+
+  status = XenSetVariableLocked(VariableName, VendorGuid, Attributes,
+                                DataSize, Data);
+
+  ReleaseSpinLock(&var_lock);
+
+  return status;
+}
+
+EFI_STATUS
+EFIAPI
+XenQueryVariableInfoLocked (
+  IN  UINT32                 Attributes,
+  OUT UINT64                 *MaximumVariableStorageSize,
+  OUT UINT64                 *RemainingVariableStorageSize,
+  OUT UINT64                 *MaximumVariableSize
+  )
+{
+  UINT8 *ptr;
+  EFI_STATUS status;
+
+  ptr = comm_buf;
+  serialize_uint32(&ptr, 1); /* version */
+  serialize_command(&ptr, COMMAND_QUERY_VARIABLE_INFO);
+  serialize_uint32(&ptr, Attributes);
+
+  exec_command();
+
+  ptr = comm_buf;
+  status = unserialize_result(&ptr);
+  switch (status) {
+  case EFI_SUCCESS:
+    *MaximumVariableStorageSize = unserialize_uint64(&ptr);
+    *RemainingVariableStorageSize = unserialize_uint64(&ptr);
+    *MaximumVariableSize = unserialize_uint64(&ptr);
+    break;
+  default:
+    break;
+  }
+  return status;
+}
+
+EFI_STATUS
+EFIAPI
+XenQueryVariableInfo (
+  IN  UINT32                 Attributes,
+  OUT UINT64                 *MaximumVariableStorageSize,
+  OUT UINT64                 *RemainingVariableStorageSize,
+  OUT UINT64                 *MaximumVariableSize
+  )
+{
+  EFI_STATUS status;
+
+  AcquireSpinLock(&var_lock);
+
+  status = XenQueryVariableInfoLocked(Attributes, MaximumVariableStorageSize,
+                                      RemainingVariableStorageSize,
+                                      MaximumVariableSize);
+
+  ReleaseSpinLock(&var_lock);
+
+  return status;
+}
+
+VOID
+EFIAPI
+VariableClassAddressChangeEvent (
+  IN EFI_EVENT        Event,
+  IN VOID             *Context
+  )
+{
+  /*
+   * Convert the comm_buf pointer from a physical to a virtual address for use
+   * at runtime.
+   */
+  EfiConvertPointer (0x0, (VOID **) &comm_buf);
+}
+
+EFI_STATUS
+EFIAPI
+VariableServiceInitialize (
+  IN EFI_HANDLE         ImageHandle,
+  IN EFI_SYSTEM_TABLE   *SystemTable
+  )
+{
+  EFI_STATUS                      Status;
+  EFI_HANDLE                      NewHandle;
+
+  comm_buf_phys = AllocateRuntimePages(16);
+  comm_buf = comm_buf_phys;
+
+  InitializeSpinLock(&var_lock);
+
+  SystemTable->RuntimeServices->GetVariable         = XenGetVariable;
+  SystemTable->RuntimeServices->GetNextVariableName = XenGetNextVariableName;
+  SystemTable->RuntimeServices->SetVariable         = XenSetVariable;
+  SystemTable->RuntimeServices->QueryVariableInfo   = XenQueryVariableInfo;
+
+  //
+  // Now install the Variable Runtime Architectural Protocol on a new handle
+  //
+  NewHandle = NULL;
+  Status = gBS->InstallMultipleProtocolInterfaces (
+                  &NewHandle,
+                  &gEfiVariableArchProtocolGuid,
+                  NULL,
+                  &gEfiVariableWriteArchProtocolGuid,
+                  NULL,
+                  NULL
+                  );
+  ASSERT_EFI_ERROR (Status);
+
+  Status = gBS->CreateEventEx (
+                  EVT_NOTIFY_SIGNAL,
+                  TPL_NOTIFY,
+                  VariableClassAddressChangeEvent,
+                  NULL,
+                  &gEfiEventVirtualAddressChangeGuid,
+                  &mXenVirtualAddressChangeEvent
+                  );
+  ASSERT_EFI_ERROR (Status);
+
+  Status = PcdSetBoolS (PcdOvmfFlashVariablesEnable, TRUE);
+  ASSERT_EFI_ERROR (Status);
+
+  return EFI_SUCCESS;
+}
diff --git a/OvmfPkg/XenVariable/XenVariable.h b/OvmfPkg/XenVariable/XenVariable.h
new file mode 100644
index 0000000000..6a6b55d0f5
--- /dev/null
+++ b/OvmfPkg/XenVariable/XenVariable.h
@@ -0,0 +1,75 @@
+#ifndef _XEN_VARIABLE_H
+#define _XEN_VARIABLE_H
+
+//
+// Statements that include other header files
+//
+#include <PiDxe.h>
+
+#include <Library/BaseLib.h>
+#include <Library/PcdLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiRuntimeLib.h>
+#include <Library/DebugLib.h>
+#include <Library/UefiLib.h>
+#include <Library/HobLib.h>
+#include <Library/DxeServicesTableLib.h>
+#include <Library/DevicePathLib.h>
+
+#include <Guid/VariableFormat.h>
+#include <Guid/GlobalVariable.h>
+#include <Protocol/Variable.h>
+#include <Protocol/VariableWrite.h>
+
+
+//
+// Functions
+//
+
+EFI_STATUS
+EFIAPI
+VariableServiceInitialize (
+  IN EFI_HANDLE         ImageHandle,
+  IN EFI_SYSTEM_TABLE   *SystemTable
+  );
+
+EFI_STATUS
+EFIAPI
+XenGetVariable (
+  IN      CHAR16            *VariableName,
+  IN      EFI_GUID          *VendorGuid,
+  OUT     UINT32            *Attributes OPTIONAL,
+  IN OUT  UINTN             *DataSize,
+  OUT     VOID              *Data OPTIONAL
+  );
+
+EFI_STATUS
+EFIAPI
+XenGetNextVariableName (
+  IN OUT  UINTN             *VariableNameSize,
+  IN OUT  CHAR16            *VariableName,
+  IN OUT  EFI_GUID          *VendorGuid
+  );
+
+EFI_STATUS
+EFIAPI
+XenSetVariable (
+  IN CHAR16                  *VariableName,
+  IN EFI_GUID                *VendorGuid,
+  IN UINT32                  Attributes,
+  IN UINTN                   DataSize,
+  IN VOID                    *Data
+  );
+
+EFI_STATUS
+EFIAPI
+XenQueryVariableInfo (
+  IN  UINT32                 Attributes,
+  OUT UINT64                 *MaximumVariableStorageSize,
+  OUT UINT64                 *RemainingVariableStorageSize,
+  OUT UINT64                 *MaximumVariableSize
+  );
+
+#endif
diff --git a/OvmfPkg/XenVariable/XenVariable.inf b/OvmfPkg/XenVariable/XenVariable.inf
new file mode 100644
index 0000000000..9a20e9a599
--- /dev/null
+++ b/OvmfPkg/XenVariable/XenVariable.inf
@@ -0,0 +1,51 @@
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = XenVariable
+  FILE_GUID                      = 3984EE42-976A-46C5-8A64-23FB340035BC
+  MODULE_TYPE                    = DXE_RUNTIME_DRIVER
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = VariableServiceInitialize
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  OvmfPkg/OvmfPkg.dec
+
+[Sources]
+  XenVariable.h
+  XenVariable.c
+
+[LibraryClasses]
+  PcdLib
+  BaseMemoryLib
+  BaseLib
+  UefiBootServicesTableLib
+  UefiRuntimeLib
+  DebugLib
+  UefiLib
+  HobLib
+  DxeServicesTableLib
+  DevicePathLib
+  UefiDriverEntryPoint
+  MemoryAllocationLib
+  SynchronizationLib
+  PciLib
+
+[Guids]
+  gEfiEventVirtualAddressChangeGuid             ## CONSUMES             ## Event
+  gEfiVariableGuid
+  gEfiGlobalVariableGuid                        ## PRODUCES ## Variable Guid
+
+[Protocols]
+  gEfiVariableArchProtocolGuid
+  gEfiVariableWriteArchProtocolGuid
+
+[Pcd]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxVariableSize
+  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxHardwareErrorVariableSize
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVariableStoreSize
+  gEfiMdeModulePkgTokenSpaceGuid.PcdHwErrStorageSize
+  gUefiOvmfPkgTokenSpaceGuid.PcdOvmfFlashVariablesEnable
+
+[Depex]
+  TRUE
